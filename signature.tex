In an ``Anonymous Credentials'' setting, the credential holders should be able to present the same credential several times to the same verifier or different verifiers without revealing their identity or being traced. However, signatures are often immutable to prevent existential forgery attacks, and therefore easily traceable. The classical solution is to replace the signature with a new, fresh zero-knowledge proof that the holder knows the signature for the credential. However, quantum-resistant zero-knowledge solutions in quantum-resistant encrypted data, signed with quantum-resistant signatures, have some challenges\cite{bootleFrameworkPracticalAnonymous2023}. Another approach is to encrypt the signature with a fresh new encryption each time a credential is presented. However, verifying an encrypted signature over encrypted data poses several challenges, with the primary one being the need for homomorphic computability in the verification process.

A signature solution proposed by Lyubashevki et al.\cite{lyubashevskyShorterLatticeBasedGroup2021} could potentially be used. However, it requires a large modulus ($q = O(2^{64})$), which is suboptimal for encryption. When the plaintext modulus is of order $O(2^{64})$, the ciphertext modulus must be of the order $O(2^{128})$, which is impractical for efficient encryption operations.

In the following subsection, we start by proposing a simple GPV-like signature
\footnote{The signature is straightforward and we are not sure that it has never been proposed before, but we could not find it.},
which is not as efficient as most existing lattice-based signatures but fits our homomorphic needs.
Then we show how to implement the signature verification step homomorphically.

\subsection{GPV-like Signature}
The proposed schema is similar to the GPV schema \cite{gentryTrapdoorsHardLattices2008}, but the hash function is replaced by a collision-resistant lattice base hash function and a pseudorandom number generator. The GPV schema uses a trapdoor $\pv{r} \in \intring_p^k$ for a vector $\pv{a} \in \intring_p^{k+2}$
to sample a short vector $\pv{s}$ from a discrete Gaussian in a lattice $\Lambda^{\perp}_{H(\boldsymbol{\mu})}(\pv{a})$,
such that $\inprod{\pv{a}}{\pv{s}}=H(\boldsymbol{\mu}) \bmod p$, where $H:\intring_q \to \intring_q$ is a polynomial hash function.

The proposed schema also samples a short vector $\pv{s}$ from a discrete Gaussian such that
\[\inprod{\pv{a}}{\pv{s}}=\inprod{\pv{b}}{\pv{\mu}}+\pvv_i \bmod p\]
where $\pvv_i$ is the $i^{th}$ element of a pseudorandom number generator $\PRGN(seed)= [\pvv_1,\ldots,\pvv_N] \in \intring_q^{N}$ and $\pv{\mu}\in\intring_p^m$ is a short vector with signed data.

\subsubsection{Signature Definition}
\begin{description}
\item[$\bkw{ParamGen}(1^{\lambda}) \to d,q,m,b,\sigma:$] Generates the schema parameters $(d,q,m,b,\sigma) \in\Z^5$ for the specified security $\lambda$. 
\item[$\bkw{KeyGen}(d,q,m,b) \to \pv{pk},\pv{sk}:$] The key generation phase starts by generating an MP12 trapdoor $(\pv{a},\pv{r}) \from \TrapGen(d,q,b,\sigma)$, with $k=\ceil{\log_b q}$, and $d$ as the ring size. Then it samples $\pv{b}\from \intring_q^m$ and $seed \from \Z$ uniformly. It returns $\pv{sk}=\pv{r} \in \intring_q^k$ and $\pv{pk}=(\pv{a},\pv{b},seed) \in \intring_q^{k+2}\times\intring_q^m\times\Z$
\item[$\bkw{Sign}(\pv{\mu}, \pv{sk}, \pv{pk}) \to \pv{\varsigma}:$] The signature phase starts by checking that $\pv{\mu} \in \intring_q^m$ and $\|\pv{\mu}\|<\sigma_{\mu}$. It gets a one-time public key $\pvv_i \from \PRGN(seed)$, increments i, computes
the syndrome $\pc=\inprod{\pv{b}}{\pv{\mu}}+\pvv_i$, and samples a short vector $\pv{s}=\SamplePre(\pc,\pv{a},\pv{r})$. It returns $\pv{\varsigma} \from (\pv{s},\pvv_i)$
\item[$\bkw{Verify}(\pv{\mu},\pv{\varsigma},\pv{pk}) \to \{1,0\}:$] The signature verification phase checks that 
\begin{align}
    &\inprod{\pv{a}}{\pv{s}}=\inprod{\pv{b}}{\pv{\mu}}+\pvv_i \bmod p \label{eq:ver_a}\\
    &\|\pv{s}\|<B_t \label{eq:ver_b}\\
    &\|\pv{\mu}\|<B_{\mu} \label{eq:ver_c}\\
    &\pvv_i \in \PRGN(seed) \label{eq:ver_d}
\end{align} 

Outputs $1$ if all equations hold and $0$ otherwise.
\end{description}

\subsubsection{Soundness and Security}
The signature schema is trivially correct by the definition of $\bkw{TrapGen}$ since every signature generated by the signing procedure is verified by the verification procedure. 

To prove security, we show that, if there is an adversary $\A$ that can generate a new valid signature $(\pv{\mu},\pv{\varsigma})$ in an existential forgery game, we can build a simulator $\B$ that solves $\RSIS_{d,q,k+2,B_t}$, $\RSIS_{d,q,m,B_{\mu}}$ or $\RSIS_{d,q,m+k+2,\sqrt{B_{\mu}^2+B_t^2}}$ with nonnegligible probability (cf. Appendix \ref{app:sigproof}).
\subsubsection{Parameter Setting}

Setting the signature parameters such that the signature is secure and yet easily encryptable is a challenge. Encrypting polynomials with large plaintext is not efficient; therefore, we choose $p$ to be the smallest possible prime value that is still secure. From \cref{eq:bound} we know that the bound $B_t=\|\pv{s}\|$ on the trapdoor-generated vector $\pv{s}\in \intring_{d,p}^{k+2}$, with $k=\ceil{\log_b{p}}$, is given by
\begin{equation}\label{eq:sbound}
B_t = s\sqrt{d(k+2)}   
\end{equation}
and from \cref{eq:rsisbound} that
\begin{equation}\label{eq:sboundrsis}
B_t < \textsf{min}(p,2^{\sqrt{4d(k+2)\log{p}\log{\delta}}})    
\end{equation}
For $\delta=1.0043$ the minimum $p$ that satisfies both equations is $p\sim O(2^{16})$, for $b=2$ and $d=64$.

In the previous section, we have defined the presentation message $\p{prt}$ (\cref{eq:presentation}) embedding the encryption of the signed data
$\enc{\p{\mu}}=\enc{\{sn,\vv{\sigma}(\pc),\vv{\mu}\}}$. However, this embedding is not possible because the signed data are embedded in a polynomial with a large norm $\p{\mu}$, and the signature algorithm signs vectors of polynomials with a small norm $\pv{\mu}$. Therefore, instead of embedding $\vv{\sigma}(\p{\mu})$ we embed a $b'$ decomposition vector $\vv{\sigma}(\pv{\mu})$, such that $\vv{\sigma}(\p{\mu}) = G.\vv{\sigma}(\pv{\mu})$, where $G=\pv{g}\otimes I$ is the so-called Gadget matrix and $\pv{g}=[1, b', {b'}^2, \ldots {b'}^{h-1}]$ the Gadget vector of polynomials of constant value. 

\subsection{Homomorphic Signature Verification}

%The signature $\pv{\varsigma}$ performed by the credential authority on the credential data $\pv{\mu}$ does not change at each use of the credential. However, both the credential data $\mu$ (including the commitment) and the $\pv{\varsigma}$ are freshly encrypted at each credential usage to ensure non-traceability. The verifier must then be able to check equations \ref{eq:verify} over encrypted data $\enc{\pv{s}}, \enc{\pvv_i}, \enc{\p{\mu}}$, using the public values of the credential authority $(\pv{a},\pv{b}, seed)$. To this end, the credential owner will also provide, together with the credential encryptions, two $\mathsf{OTK}$ keys to decrypt the results of two homomorphic functions without revealing their encrypted parameters.

The purpose of this section is to describe the implementation of homomorphic signature verification.

\begin{equation} \label{eq:hverify}
\begin{split}
\overline{\bkw{Verify}}: &\intring_q^2,\intring_q^{k+2}\times\intring_q^m\times\Z \rightarrow \intring_q^2\\
      &\p{prt},\pv{pk} \rightarrow \left\{\enc{\pv{0}},\enc{\pv{x}}\right\}
\end{split}
\end{equation}

The primitive $\overline{\bkw{Verify}}$ takes two arguments, the encrypted presentation $\p{prt}\in \intring_q^2$ and the issuer's public key $\pv{pk}\in \intring_q^{k+2}\times\intring_q^m\times\Z$ and outputs and encryption of zero if the verification is successful or something else if the verification is not successful.

The homomorphic verification of the signature is valid if the homomorphic verification of each of the \cref{eq:ver_a,eq:ver_b,eq:ver_c,eq:ver_d} is valid. whereas \cref{eq:ver_a} is trivially verified by computing 
\begin{equation}\label{eq:hvera}
%\begin{multline}\label{eq:hvera}
\SUM_{k+2,d}\Bigl(\enc{\pv{s}}\odot \pv{a}\Bigr)-\SUM_{h,d}\left(\enc{\pv{\mu}}\odot \pv{b}\right)-\enc{\pvv_i}        
%\end{multline}
\end{equation}
and testing for zero, the others are slightly more involved. The next two subsections will address the verification of the norm-bound equations (\cref{eq:ver_b,eq:ver_c}) and the $\PRGN$ membership test \cref{eq:ver_d}, respectively.

%of three steps, corresponding to the verification of \cref{eq:ver_a,eq:ver_b,eq:ver_c}, which will be explained in the next three sections. 

%\subsubsection{Signature and Data Encryption}

%The main challenge to the verification eq. \ref{eq:ver_a} homomorphically is setting signature parameters such that the signature is secure and yet easily encryptable. Encrypting polynomials with large plaintext is not efficient; therefore, we choose $p$ to be the smallest possible prime value that is still secure. From eq. \ref{eq:bound} we know that the bound $B_t=\|\pv{s}\|$ on the trapdoor-generated vector $\pv{s}\in \intring_{d,p}^{k+2}$, with $k=\ceil{\log_b{p}}$, is given by
%\[B_t = s\sqrt{d(k+2)}\] and from eq. \ref{eq:rsisbound} that 
%\[B_t < \textsf{min}(p,2^{\sqrt{4d(k+2)\log{p}\log{\delta}}})\]
%For $\delta=1.0043$ the minimum $p$ that satisfies both equations is $p\sim O(2^{16})$, for $b=2$ and $d=64$.

%In the previous section, we have defined the presentation message $\enc{m}$ (eq. \ref{eq:presentation}) embedding the encryption of the signed data $\enc{\p{\mu}}=\enc{(\vv{\sigma}(\pc),\vv{\mu})}$. However, this embedding is not possible because the signed data is a polynomial with a large norm $\p{\mu}$, and the signature algorithm signs vectors of polynomials with a small norm $\pv{\mu}$

%Therefore, instead of embedding $\vv{\sigma}(\p{\mu})$ we embed a $b'$ decomposition vector $\vv{\sigma}(\pv{\mu})$, such that $\vv{\sigma}(\p{\mu}) = G.\vv{\sigma}(\pv{\mu})$, where $G=\pv{g}\otimes I$ is the so-called Gadget matrix and $\pv{g}=[1, b', {b'}^2, \ldots {b'}^{h-1}]$ the Gadget vector of polynomials of constant value.    
%Therefore, we verify Equation \ref{eq:ver_a} by extracting $\enc{\pv{s}}$, $\enc{\pvv_i}$ and $\enc{\pv{\mu}}$ from the presentation message $\enc{\p{m}}$, computing
%\begin{equation}\label{eq:hvera}
%\begin{multline}\label{eq:hvera}
%\mathbf{SumSlots}_{k+2,d}\Bigl(\enc{\pv{s}}\odot \pv{a}\Bigr)-\\\mathbf{SumSlots}_{h,d}\left(\enc{\pv{\mu}}\odot \pv{b}\right)-\enc{\pvv_i}        
%\end{multline}
%\end{equation}
%and testing for zero.


\subsubsection{Bounded Norm Check}\label{sec:bnc}

The homomorphic verification of \cref{eq:ver_c} for some bound $B_{\mu}=\textsf{min}(p,2^{\sqrt{4d.l\log{p}\log{\delta}}})$ that makes $\RSIS_{d,q,m,B_{\mu}}$ difficult can be achieved by checking that $\enc{\pv{\mu}}$ encrypts a polynomial vector containing binary slot values (i.e., $b'=2$). In fact, taking advantage of the norm inequalities \cite{damgardMultipartyComputationSomewhat2012}, if $\vv{\sigma}(\pv{\mu}) \in \{0,1\}$ then
\[\|\pv{\mu}\| \le \sqrt{h.d}\|\pv{\mu}\|_{\infty} \le \sqrt{h.d}\|\vv{\sigma}(\pv{\mu})\|_{\infty} = \sqrt{h.d} \ll B_{\mu}\]
%\[B_{\mu}= \sqrt{h.d} = \sqrt{h.d}\|\vv{\sigma}(\pv{\mu})\|_{\infty} \ge \sqrt{h.d}\|\pv{\mu}\|_{\infty} \ge \|\pv{\mu}\|\]

%$B_{\mu}=\|\pv{\mu}\|< \sqrt{h.d} \ll \textsf{min}(p,2^{\sqrt{4d.l\log{p}\log{\delta}}})$.

%Recall that for the power of two cyclotomic rings $\|\pa\|_{\infty}\leq\|\vv{\sigma}(\pa)\|_{\infty}$ \cite{damgardMultipartyComputationSomewhat2012}, therefore, if $\pv{\mu}$ is a vector of polynomials encoding 0s and 1s, then $B_{\mu}=\|\pv{\mu}\|< \sqrt{h.d} \ll \textsf{min}(p,2^{\sqrt{4d.l\log{p}\log{\delta}}})$.

The homomorphic multiplication of two encrypted values is equivalent to the elementwise modular multiplication of their canonical vectors, therefore by lemma \ref{lm:binary}, 
$\enc{\pv{\mu}}$ encrypts a polynomial vector containing binary slot values if and only if 
\begin{equation}\label{eq:hbinmsg}
    \enc{\pv{\mu}}\odot(\vv{1}-\enc{\pv{\mu}})\stackrel{?}{=}\enc{\pv{0}}
\end{equation}

The homomorphic verification of \cref{eq:ver_b} is slightly more involved. 
We take advantage that any vector $\pv{s}$ sampled by $\bkw{TrapSampl}$ has norm $\|\pv{s}\|_{\infty}< s$ w.h.p.\footnote{If that is not the case the signature issuer should sample the vector again.}, and that $\|\vv{\sigma}(\pv{s})\|_{\infty}\leq \sqrt{d}\|\pv{s}\|_{\infty}$ \cite{damgardMultipartyComputationSomewhat2012}, to infer the maximum amount of bits $w=\ceil{\log s\sqrt{d}}$ needed to encode the modulo of each element of $\vv{\sigma}(\pv{s})$, and
replace the embedding of $\pv{s}$ in the encrypted presentation $\p{prt}$ by embedding a special decomposition 
\[\vv{\sigma}(\pv{s})^* = (\vv{\sigma}(\pv{s})^-,\vv{\sigma}(\pv{s})^+)\]

The key intuition is that $\vv{\sigma}(\pv{s})^- \in \{1,-1\}^{d(k+2)}$ encodes the signal of every element of $\vv{\sigma}(\pv{s})$ and $\vv{\sigma}(\pv{s})^+ \in \{0,1\}^{d.w(k+2)}$ encodes a binary representation of the modulo of every element in $\vv{\sigma}(\pv{s})$, such that it is possible to reconstruct $\vv{\sigma}(\pv{s})$ by the linear operation
\begin{equation}\label{eq:sdecomp}
    \vv{\sigma}(\pv{s}) = \vv{\sigma}(\pv{s})^-\odot(\mG.\vv{\sigma}(\pv{s})^+)
\end{equation}


%Let $\vv{a}^* = (\vv{a}^-,\vv{a}^+) \in \Z^{n(w+1)}$ be a special decomposition of vector $\vv{a} \in \Z^n$, such that
%\begin{equation}\label{eq:sdecomp}
%    \vv{a} = \vv{a}^-\odot(\mG.\vv{a}^+)
%\end{equation}
%where
%\begin{align*}
%    &\mG = \pv{g}\otimes I_h && \text{\small{Is the gadget matrix}}\\
%    &I_h && \text{\small{Is identity matrix of dimension $h\times h$}}\\
%    &\pv{g} = [1,2,\ldots,2^w]  &&\text{\small{Is the gadget vector}}\\
%    & w = \ceil{\log \|a\|_{\infty}} &&\text{\small{Is the maximum bit size of $\|\pv{a}\|_{\infty}$}} \\
%    &\vv{a}^- \in \{-1,1\}^n && \text{\small{Is a vector encoding the signal of each $a_i$}} \\
%    &\vv{a}^+ \in \{0,1\}^{n.w} && \text{\small{Is the concatenation of the binary}}\\
%    &&&\text{\small{decomposition of each $|a_i|$}}
%\end{align*}

%Then, instead of embedding $\vv{\sigma}(\pv{s}) \in \Z^{d(k+2)}$ in the presentation message, we embed $\vv{\sigma}(\pv{s})^* \in \Z^{d.(w+1)(k+2)}$, and compute $\enc{\pv{s}}$ by homomorphic computing equation \ref{eq:sdecomp}.

Therefore, the homomorphic verification of the norm bound of \cref{eq:ver_b} subsumes to the verification that each each element of $\vv{\sigma}(\pv{s})^+$ is 0 or 1, and that each element in $\vv{\sigma}(\pv{s})^-$ is either -1 or 1, by using Lemma \ref{lm:binary} and Lemma \ref{lm:sign}, respectively, homomorphically
\begin{equation}\label{eq:signbound}
\begin{split}
\enc{\vv{\sigma}(\pv{s})^+}.(\pv{1}-\enc{\vv{\sigma}(\pv{s})^+}) \stackrel{?}{=}\enc{\vv{0}}\\
(\pv{1}+\enc{\vv{\sigma}(\pv{s})^-}).(\pv{1}-\enc{\vv{\sigma}(\pv{s})^-}) \stackrel{?}{=}\enc{\vv{0}} \\ 
\end{split}   
\end{equation}

Proving these properties proves that $\|\pv{s}\|_{\infty}<2^w$, which is usually enough (cf. Appendix \ref{app:enb}).

\subsubsection{Homomorphic PRGN Computation}

Homomorfically checking that \cref{eq:ver_d} holds can be done using the $\PSM$ operation (Section \ref{sec:psm}) or the one-out-of-many proof proposed in \cite{lyubashevskySMILESetMembership2021}. However, none of them scales well. $\PSM$ may only be used efficiently for small sets and small string sizes (Figure \ref{fig:string}), while the validation of the one-out-of-many proof from \cite{lyubashevskySMILESetMembership2021} scales linearly with the number of maximum signatures allowed for each key. The proposed schema scales logarithmically with the maximum number of signatures allowed, making this limit irrelevant.

The main insight of our approach is to implement $\PRGN(seed)$ using a homomorphically computable pseudo-random function $\PRF(seed,i)$ and recompute
\begin{equation}\label{eq:prf}
\enc{\pvv_i}=\overline{\PRF}(seed,\enc{i})
\end{equation}
homomorphically. If the maximum number of signatures $N = 2^m$ is set to be the biggest number that can be encoded in $\Enc(i)$ then the computed $\enc{\pv{v}_i} \in \overline{\PRGN}(seed)$.

The variant $\RLWE$ of the $\PRF$ proposed by Boneh et al. \cite{bonehKeyHomomorphicPRFs2013} almost fits our needs. It may be described as
\begin{align}
&\PRF(\textrm{seed},\nu)= \inprod{\round{\pv{f}^*}_{\beta}}{\pv{g}} \label{eq:bonehround}\\
&\pv{f}^* = \ps.\left(\prod_{j=0}^{m-1} \mP_0.(1-\nu_j) + \mP_1.\nu_j\right) \label{eq:bonehprf}
\end{align}
where

\begin{tabular}{lll}
$\pv{g}$ &$= [1,\beta,\ldots,\beta^{\ceil{\log_{\beta} p}}]$ &\small{is the gadget vector}\\
$\ps$ &$= Enc(seed) \in \intring_{d,p}$ &\small{is the ring encoding of the seed}\\
$\vv{\nu}$ &$= \inv{g}(\nu)$ &\small{is the bit decomposition of $\nu$}\\
$\mP_i$ &$\in \intring^{\alpha\times\alpha}_{d,p}$ &\small{are random binary matrixes}\\
$\alpha$ &$= \ceil{\log_2 p}$ &\small{is the number of bits of $p$}\\
$\round{x}_{\beta}$ &\multicolumn{2}{l}{\small{denotes rounding an element $x \in \Z_p$ to $\Z_{\beta}$, $\beta<p$,}}\\
&\multicolumn{2}{l}{\small{by multiplying it by $(\beta/p)$ and rounding the result}}
\end{tabular}

Homomorphically computing an encryption of $\pv{f}^*$ (\cref{eq:bonehprf}) from $\enc{\vv{\nu}}$ is relatively straightforward. However, performing the rounding operation in \cref{eq:bonehround} homomorphically presents a greater challenge. This challenge closely resembles the rounding step found in $\BFV$ or $\BGV$ bootstrapping \cite{gentryBetterBootstrappingFully2012}, and similar techniques can be applied. However, the substantial multiplication depth required for both the rounding operation in \cref{eq:bonehround} and the computation of \cref{eq:bonehprf} requires the use of large and inefficient rings.

Instead, we provide the verifier with $\enc{\pv{x}}=\enc{\round{\pv{f}^*}_{\beta}}$, from which the verifier can compute $\enc{\pvv_i}$ from \cref{eq:bonehround}, and leverage the proposal from \cite{libertZeroKnowledgeArgumentsLatticeBased2017} to check that $\enc{\pv{x}}=\enc{\round{\pv{f}^*}_{\beta} \bmod p}$, by homomorphically checking that
\begin{align}\label{eq:roundproof}
&p.\enc{\pv{x}}=\beta.\enc{\pv{f}^*}+\senc{\pv{z}}{\beta} \;\;\;(\bmod \beta.p)\\
&\|\vv{\sigma}(\pv{x})\|_{\infty}=\beta \quad \|\vv{\sigma}(\pv{f}^*)\|_{\infty}<p  \quad \|\vv{\sigma}(\pv{z})\|_{\infty}<p \label{eq:normproof}
\end{align}
where $\senc{\pv{z}}{\beta}$ is an ecryption modulo $\beta.q$ of a polynomial $\pv{z} \in \intring^{\alpha}_{d,\beta.p}$, with $\|\pv{z}\|_{\infty}< p$ that makes \cref{eq:roundproof} true.

Checking \cref{eq:roundproof} homomorphically is not straightforward because it must be done modulo $\beta.p$, and while $\senc{\pv{z}}{\beta}$ encrypts a plaintext modulo $\beta.p$, $\enc{\pv{x}}$ and $\enc{\pv{f}^*}$ encrypt plaintext modulo $p$. However, it can be shown (Appendix \ref{app:sotkdec}) that for $\BFV$ encryptions, the $\bkw{OTKDecrypt}$ algorithm over plaintext modulo $\beta.p$ and ciphertext modulo $p.q$ (denoted $\bkw{OTKDecrypt}_{\beta}$) correctly decrypts \cref{eq:roundproof} provided that $\beta\ll p$. 

Checking \cref{eq:roundproof} homomorphically is a question of computing
\[
\enc{\pv{\gamma}}=\beta.\enc{\pv{f}^*}+\senc{\pv{z}}{\beta}-p.\enc{\pv{x}} \;\;\;(\bmod \beta.p)
\]
and testing
\begin{equation}\label{eq:homoroundproof}
   \textsf{OTKDecrypt}_{\beta}(\pv{pk},\pv{otk},\enc{\p{\gamma_i}}) \stackrel{?}{=} \p{0} \quad\quad \forall_{0\leq i < \alpha} 
\end{equation}

%where
%\begin{align*}
%&\pv{otk}=\textsf{TrapSamp}(\pv{a},\pv{mk},\pc_i)
%&&\pv{a} \in \intring_q^{k+2}&&& %k=\ceil{\log_b(\beta.q)}
%\end{align*}


Finally, the verifier must check the norms in \cref{eq:normproof}. The first one can be check easily if $\beta=2$, by Lemma \ref{lm:binary}
\begin{equation}\label{eq:hbinprgn}
    \enc{\pv{x}}.(1-\enc{\pv{x}})\stackrel{?}{=}\enc{\pv{0}} 
\end{equation}
The second is implicitly true because $\enc{\pv{y}}$ encrypts a plaintext modulo $p$, but the third requires replacing the embed encryption $\senc{\pv{z}}{\beta}$ in $\enc{\p{m}}$ by the encryption of special decomposition $\vv{\sigma}(\pv{z})^*=(\vv{\sigma}(\pv{z})^-,\vv{\sigma}(\pv{z})^+)$ (see \cref{eq:sdecomp}), and then check
\begin{align}
&\senc{\pv{z}^+}{\beta}\odot\left(\pv{1}-\senc{\pv{z}^+}{\beta}\right)\stackrel{?}{=}\senc{0}{\beta} \label{eq:hxparmodulo}\\
&\left(\pv{1}+\senc{\pv{z}^-}{\beta}\right)\odot\left(\pv{1}-\senc{\pv{z}^-}{\beta}\right)\stackrel{?}{=}\senc{0}{\beta} \label{eq:hxparsignal}
\end{align}


\subsubsection{Signature Verification}\label{sec:allsig}

The general signature verification resumes to homomorphically test for zero \cref{eq:hvera,eq:hbinmsg,eq:signbound,eq:homoroundproof,eq:hbinprgn,eq:hxparmodulo,eq:hxparsignal}. Generating and transmitting $\pv{otk}$ for all of these tests is cumbersome and inefficient. Fortunately, the number of $\pv{otk}$ can be reduced to only 2 by grouping the tests $\senc{\pt_i}{x}$ by decryption modulo, and them compute
\[\senc{\p{T}}{x}=\sum \textsf{Hash}(\senc{\p{t_i}}{x}).\senc{\p{t_i}}{x}\stackrel{?}{=} \senc{\p{0}}{x}\]
and test for zero the result, which will be zero only if all $\enc{\p{t_i}}\stackrel{?}{=} \p{0}$ are zero encryptions, with high probability\cite{lyubashevskyLatticeBasedZeroKnowledgeProofs2022}.  Equations \cref{eq:hvera,eq:hbinmsg,eq:signbound,eq:hbinprgn} can be grouped together and eventually with any tests for zero required to compute over attributes (e.g. is age over 18). All are computed over plaintext $p$ and ciphertext $q$, and therefore can be decrypted with $\pv{otk} \in \intring^{k+2}_{d',q}$. Equations \cref{eq:homoroundproof,eq:hxparmodulo,eq:hxparsignal} are computed on plaintext $\beta.p$ and ciphertext $\beta.q$ and require a different $\pv{otk}_{\beta} \in \intring^{k+2}_{d',\beta.q}$.

The different modulo used in some of the encryptions in equations \cref{eq:homoroundproof,eq:hxparmodulo,eq:hxparsignal} also affect the presentation message. Instead of one encryption $\enc{m}$ we need two
\begin{align*}
 &\enc{m_0} = \enc{\{\vv{0},\cd{\pc}, \cdv{\mu}, \cdv{o}, \cdv{s}^*, \vv{\nu}, \cdv{x}\}} \\
 &\senc{m_1}{\beta} = \senc{\{\vv{0},\cdv{z}^*\}}{\beta}  
\end{align*}
The holder must send both encryptions and both $\pv{otk}$ to the verifer, which is about $904KB$ in size, assuming a ring size $d'=8192$, a ciphertext modulus $\approx\log q=88$ bits, and two $\pv{otk} \in \intring^6_{d',q}$ vectors such that $\|\pv{otk}\|_{\infty} < 2^{44}$.


This value is cut to $734KB$ using the ring-switching technique from \cite{gentryRingSwitchingBGVStyle2012} on $\senc{m_1}{\beta}$, given that the computations with it are shallow and only 256 slots are filled. The encryption $\senc{m_1}{\beta}$ and the corresponding $\pv{otk}$ key can be eliminated if a different technique is used to test whether $\pvv_i \in \mathsf{PRGN}(seed)$ is used or if instead a signature such as the one proposed in \cite{bootleFrameworkPracticalAnonymous2023} is used, which would reduce the overall size of the presentation to $\approx 452KB$. Further reducing the size of the presentation seems to imply a fundamental change in the proposed paradigm.