\section{PSM Detailed Algorithms}\label{app:psmalgorithms}
We describe below the detailed PSM algorithms.

\begin{algorithm}[ht]
\caption{Spread Function}\label{alg:spread}
\small
\begin{algorithmic}
\Function {Spread}{$\enc{x}$, d}
    \State $t \gets 1$
    \State $\encv{\py} \gets \encv{1}$
    \State $\enc{\px} \gets \enc{x}$
    \While{$d > 1$}
        \If{d is odd}
            \State $\enc{\py} \gets \enc{\px} + \enc{\py} \RotateLeft t$
        \EndIf
        \State $\enc{\px} \gets \enc{\px} + \enc{\px} \RotateLeft t$
        \State $t \gets 2*t$
        \State $d \gets \floor{d/2}$
    \EndWhile
    \State \Return $\enc{\px} + \enc{\py} \RotateLeft t$
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[ht]
\caption{Sum All Slots Function}\label{alg:sumall}
\small
\begin{algorithmic}
\Function {SumAll}{$\enc{\px}$, d}
    \State $t \gets 2^{\floor{\log_2{d}}-1}$
    \State $t_1 \gets 2^{\floor{\log_2{d}}}$
    \State $\enc{\py} \gets \enc{\px}$
    \While{$t > 0$}
        \State $\enc{\py} \gets \enc{\px} + \enc{\py} \RotateRight t$
        \If{$t \BitAnd{d}$}
            \State $\enc{\px} \gets \enc{\px} + \enc{\py} \RotateRight t_1$
            \State $t_1 \gets t$
        \EndIf
        \State $t \gets \floor{t/2}$
    \EndWhile
    \State \Return $\enc{\px}$
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[ht]
\caption{Subtract and Map}\label{alg:subadd}
\small
\begin{algorithmic}
\Function {SubMapAdd}{$\enc{\px}$, $\overrightarrow{\bm{s}}$, $e$}
    \State $\enc{\po} \gets \bot$
    \ForAll{$\ps_i \gets \pv{s}$}
        \State $\enc{\pt} \gets \enc{\px}-\ps_i$
        \State $\enc{\pt} \gets \Call{IsZero}{\enc{o}}$\Comment{\small{Map every slot to $\enc{0}$ or $\enc{1}$}}
        \State $\enc{\po} \gets \enc{\po} + \Call{ProdAll}{\enc{\pt},e}$
    \EndFor
    \State \Return $\enc{\po}$
\EndFunction
\end{algorithmic}
\end{algorithm}

\section{GPV-like Signature Security Proof}\label{app:sigproof}
To prove security, we show that if there is an adversary $\A$ that can generate a new valid signature $(\pv{\mu},\pv{\varsigma})$ in an existential forgery game, we can build a simulator $\B$ that solves $\RSIS_{d,q,k+2,B_t}$, $\RSIS_{d,q,m,B_{\mu}}$ or $\RSIS_{d,q,m+k+2,\sqrt{B_{\mu}^2+B_t^2}}$ with nonnegligible probability.

The adversary $\A$ can request from $\B$ at most $N$ signatures for chosen messages $\pv{\mu_i}$, for which the simulator $\B$ proceeds as follows. Samples a sort vector $\pv{s_i} \from \D_{\intring_q^{k+2},\sigma_s}$, computes $\pvv_i=\inprod{\pv{a}}{\pv{s_i}}-\inprod{\pv{b}}{\pv{\mu_i}}$, programs $\PRGN(seed)$ to include $\pvv_i$, and returns a signature $(\pv{\mu_i},\pv{s_i},\pvv_i)$. In some cases, the adversary may choose to request only the one-time public key $\pvv_i$. In such situations, the simulator $\B$ samples a message $\pv{\mu_i} \from \intring_q^m$ and proceeds as before.

The distribution of the signature tuples $(\pv{\mu_i},\pv{s_i},\pvv_i)$ generated by this procedure is indistinguishable from the one generated by the actual signature schema. Notice that $\pv{s_i}$ is drawn from the same distribution as when it is sampled by $\SamplePre$ and $\pvv_i$ is uniformly random, provided that $\sigma_s$ is greater than the smoothing factor of the lattice $\Lambda_{\pv{a}}^{\bot}$ smoothing factor \cite{micciancioWorstcaseAveragecaseReductions2007}.

The existential forgery $(\pv{\mu},\pv{s},\pvv)$ provided by the adversary $\A$ at the end of the game must satisfy equations \cref{eq:ver_a,eq:ver_b,eq:ver_c,eq:ver_d} to win the game. To this end, the adversary $\A$ must choose $\pvv$ from the set of one-time public keys disclosed $[\pvv_1,\ldots,\pvv_l]$, $l<N$, or guess one $\pvv = [\pvv_{l+1},\ldots,\pvv_N]$ not yet disclosed. Assuming a secure $\mathsf{PRGN}$, the probability of guessing one not yet disclosed is $P=\frac{N}{|\intring_q|}$, which is easily negligible.

If $\A$ chooses a $\pvv \from [\pvv_1,\ldots,\pvv_l]$ then $\B$ has a signature $(\pv{\mu_i},\pv{s_i},\pvv)$ for the same $\pvv$, and may compute
\begin{equation}\inprod{\pv{a}}{\pv{s}-\pv{s_i}} = \inprod{\pv{b}}{\pv{\mu}-\pv{\mu_i}}\end{equation}
If $\pv{\mu}=\pv{\mu_i}$ then $\B$ outputs $\pv{s}' = \pv{s}-\pv{s_i}$ as a solution for $\RSIS_{d,q,k+2,B_t}$. If $\pv{s}=\pv{s_i}$ then $\B$ outputs $\pv{m} = \pv{\mu}-\pv{\mu_i}$ as a solution for $\RSIS_{d,q,m,B_{\mu}}$, otherwise it outputs $\pv{c}=[\pv{s}-\pv{s_i}\|\pv{\mu}-\pv{\mu_i}]$ as a solution for \[\RSIS_{d,q,m+k+2,\sqrt{B_{\mu}^2+B_t^2}}\]

\section{Exact Norm Bound}\label{app:enb}

In Section \ref{sec:bnc} we have shown how to check an approximate bound $2^w$ of the norm of a specific vector $\pv{s}$ encoded in the encrypted presentation when that vector is sampled by \bkw{TrampSampl}. We rely on the sampled vector satisfying $\|\pv{s}\|<s$ w.h.p. to encode each element of $\pv{\sigma}(\pv{s})$ in $w+1$ bits; one for the sign and $w=\ceil{\log s\sqrt{d}}$ for the modulo. Let $\pv{\sigma}(\pv{s})^{-} \in \{1,-1\}^{d(k+2)}$ denote the vector with the sign of each element of $\pv{\sigma}(\pv{s})$, and $\pv{\sigma}(\pv{s})^{+} \in \{0,1\}^{d.w(k+2)}$ the bit decomposition of the modulo of each element of $\pv{\sigma}(\pv{s})$, then it is possible to both recover \[\pv{\sigma}(\pv{s}) = \pv{\sigma}(\pv{s})^{-} \odot (G.\pv{\sigma}(\pv{s})^{+})\]
and to verify that $\pv{\sigma}(\pv{s})^{-} \in \{1,-1\}^{d(k+2)}$, and that $\pv{\sigma}(\pv{s})^{+} \in \{0,1\}^{d.w(k+2)}$ by using lemmas \ref{lm:sign} and \ref{lm:binary}, homomorphically.

Although, ensuring that $\|\pv{s}\|_{\infty}<2^w$ is usually enough to ensure $\RSIS_{d,q,m,B'_t}$ hardness, with 
\[B'_t=2^w\sqrt{d(k+2)} < \textsf{min}(p,2^{\sqrt{4d(k+2)\log{p}\log{\delta}}})\]
(cf. \cref{eq:sbound}) it does not prove that $\|\pv{s}\|_{\infty}<s$. However, if necessary, following the strategy from \cite{lyubashevskyLatticeBasedZeroKnowledgeProofs2022}, the holder may send another binary encrypted decomposed value $\vv{b}^{+} \in \{0,1\}^{d.w(k+2)}$, such that
\begin{equation}\label{eq:exactbound}
    s.\vv{1} = G.\left(\vv{\sigma}(\pv{s})^{+} + \vv{b}^{+}\right)
\end{equation}
The verifier checks that $\enc{\vv{b}^{+}}$ encrypt a binary vector and that \cref{eq:exactbound} holds homomorphically, which indirectly ensures that $\|\vv{\sigma}(\pv{s})^{+}\|_{\infty}<s$

\section{OTK Decryption on bigger modulo}\label{app:sotkdec}

The proof of the correct decryption of \cref{eq:roundproof} using the $\bkw{OTKDecrypt}_{\beta}$ algorithm is just an algebraic unroll of the $\bkw{OTKDecrypt}_{\beta}$ definition that we described here for completeness.

Specifically, we want to show that, if 
\begin{align*}
&\enc{\pc}=\beta.\enc{\py}+\senc{\pz}{\beta}-p.\enc{\px} \;\;\;(\bmod \beta p)\\
&\beta\ll p
\end{align*}
then
\begin{equation*}
   \textsf{OTKDecrypt}_{\beta}(\p{PK},\pv{otk},\enc{\pc}) = \beta.\py+\pz-p.\px
\end{equation*}

Let $\enc{\pc}=(\pc_0,\pc_1), \enc{\py}=(\py_0,\py_1), \senc{\pz}{\beta}=(\pz_0,\pz_1)$ and $\enc{\px}=(\px_0,\px_1)$, then
\begin{align*}
&\textsf{OTKDecrypt}_{\beta}(\p{PK},\pv{otk},\enc{\pc_i}) =\\
&\Gamma\left(\pc_1 - \inprod{\pv{otk}}{\pv{b}} \bmod p.q\right)=\\
&\Gamma\left(\pc_1 - \ps.\pc_0+\inprod{\pv{otk}}{\pv{e}} \bmod p.q\right)=\\
&\Gamma\left(\beta(\py_1 - \ps.\py_0)+(\pz_1-s.\pz_0)-p(\px_0-s.\px_1)+\right.\\
&\quad\quad\left.\inprod{\pv{otk}}{\pv{e}} \bmod p.q\right)=\\
&\Gamma\left(\beta(\Delta\py +\pe'+k'q) +(\Delta\pz+\pe''+k''\beta q)-p(\Delta\px+\pe'''+k'''q)+\right.\\
&\quad\quad\left.\inprod{\pv{otk}}{\pv{e}} \bmod p.q\right)=\\
&\Gamma\left(\Delta(\beta\py+\pz-p\px)+(\beta\pe'+\pe''-p\pe''')+(k'\beta q+ k''\beta q-k'''p.q)+\right.\\
&\quad\quad\left.\inprod{\pv{otk}}{\pv{e}} \bmod p.q\right)=\\
&\Gamma\left(\Delta(\beta\py+\pz-p\px)+(\beta\pe'+\pe''-p\pe''')+\right.\\
&\quad\quad\left.k\beta q +\inprod{\pv{otk}}{\pv{e}} \bmod p.q\right)=\hspace{8em}(\textrm{if } \beta\ll p)\\
&\round{(\beta\py+\pz-p\px)+\frac{1}{\Delta}(\beta\pe'+\pe''-p\pe''')+k\beta p +\inprod{\pv{otk}}{\pv{e}} \bmod \beta p} =\\
&\beta\py+\pz-p\px
\end{align*}


